---
title: "General use"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{General use}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment  = "#>", 
  # error    = TRUE, 
  purl     = FALSE
)
```

## The basics

Notice too that `joyn::merge` masks `base::merge`, which is ideal.

```{r setup}
library(joyn)
library(data.table)
x1 = data.table(id = c(1L, 1L, 2L, 3L, NA_integer_),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = 11:15)

y1 = data.table(id = c(1,2, 4),
                y  = c(11L, 15L, 16))


x2 = data.table(id = c(1, 4, 2, 3, NA),
                t  = c(1L, 2L, 1L, 2L, NA_integer_),
                x  = c(16, 12, NA, NA, 15))


y2 = data.table(id = c(1, 2, 5, 6, 3),
                yd = c(1, 2, 5, 6, 3),
                y  = c(11L, 15L, 20L, 13L, 10L),
                x  = c(16:20))


y3 <- data.table(id = c("c","b", "c", "a"),
                 y  = c(11L, 15L, 18L, 20L))

x3 <- data.table(id=c("c","b", "d"),
                 v=8:10,
                 foo=c(4,2, 7))

x4 = data.table(id1 = c(1, 1, 2, 3, 3),
                id2 = c(1, 1, 2, 3, 4),
                t   = c(1L, 2L, 1L, 2L, NA_integer_),
                x   = c(16, 12, NA, NA, 15))


y4 = data.table(id  = c(1, 2, 5, 6, 3),
                id2 = c(1, 1, 2, 3, 4),
                y   = c(11L, 15L, 20L, 13L, 10L),
                x   = c(16:20))
```

### Summary table

You can see in the examples below that by default `joyn` displays a small
summary table.

```{r}
# Natural join. i.e., using as key all the variables that appear in both tables.
# without display the resulting table.
merge(x1, y1)
```

You can use the reporting format of the `report` variables, by setting the
argument `reporttype` to numeric, similar to Stata's output.

```{r, echo=FALSE}
knitr::kable(
  tibble::tribble(
~code, ~report, ~meaning,
1, "x", "Only available in x table",
2, "y", "Only available in y table",
3, "x & y", "Matching obs available in both tables",
4, "NA updated", "NAs in x updated with actual values in variables with same names in y",
5, "value updated", "Actual values and NAs in x updated with actual values in variables with same names in y",
6, "not updated", "Actual values and NAs in x are NOT updated with actual values in y"
), format = "simple", align = "lcl")
```

### Key variables

Since the object returned is a `data.table`, we display the results in the
console by concatenating a pair of squared brackets at the end of the call. That
is `merge(x1, y1)[]` instead of `merge(x1, y1)`.

```{r}
# Natural join.  display the results.
merge(x1, y1)[]

# Making explicit the key variables (strongly suggested)
merge(x1, y1, by = "id")[]
```

If the key variables have different names in both tables, you can create the
equivalency as an element of `by` vector.

```{r}
# joining by id1 in x and id in y
merge(x4, y4, by = c("id1 = id"))

# joining by id1 in x and id in y, and id2  in both
merge(x4, y4, by = c("id1 = id", "id2"))
```

## Match type

Match type refers to the correspondence that exists between the observations of
the joining tables. Following Stata's convention, we could have four different
match types, one-to-one (1:1) , one-to-many (1:m), many-to-one (m:1), and
many-to-many (m:m) joins. The default is m:m, following general R's practice,
but its use is **highly discouraged**. We recommend you always specify the match
type when joining tables to ensure the output is correct. Indeed, if you don't
care about match types or you don't think it is necessary to use them for your
particular needs, you might be fine without `joyn`.

Using the same wording of the [Stata
manual](https://www.stata.com/manuals/dmerge.pdf)

-   **1:1**: specifies a one-to-one match merge. The variables specified in `by`
    *uniquely identify* single observations in both table.

-   **1:m and m:1**: specify *one-to-many* and *many-to-one* match merges,
    respectively. This means that in of the tables the observations are uniquely
    identify by the variables in `by,` while in the other table many (two or
    more) of the observations are identify by the variables in `by`.

-   **m:m** refers to *many-to-many joins*. variables in `by` does not uniquely
    identify the observations in either table. Matching is performed by
    combining observations with equal values in `by`; within matching values,
    the first observation in the master (i.e. left or x) table is matched with
    the first matching observation in the using (i.e. right or y) table; the
    second, with the second; and so on. If there is an unequal number of
    observations within a group, then the last observation of the shorter group
    is used repeatedly to match with subsequent observations of the longer
    group.

Suppose you think your data is uniquely identified by variable `id`, it is not .
If you used `match_type = "1:1"` you will get and error, letting you know that
something is not right.

```{r join-type, error=TRUE}
# Merging correctly but getting error because something is not right in the data
merge(x3, y3, by = "id", match_type = "1:1")

# Merging wrongly but getting NO errors because  you did not use match_type
merge(x3, y3, by = "id")
```

## Join type

Join type refers to observations that are kept after the join. To avoid
confusion with argument `match_type`, I decided not to name this argument as
`join_type` but as `keep`. At the end, you want to specify which observations
you want to keep. This argument plays the role of mimicking the behavior of
`dplyr`'s functions `left_join`, `right_join`, `inner_join`, and `full_join`,
the default.

-   `keep = "full"`, the default, keeps all the observations in x and y,
    regardless of whether they match or not.

    ```{r}
    # Full merge
    merge(x1, y1)
    ```

-   `keep = "left"` or `keep = "master"` keeps all observations in x, regardless
    of whether they match or not with y.

    ```{r}
    # keep obs in x
    merge(x1, y1, keep = "left")
    ```

-   `keep = "right"` or `keep = "using"` keeps all observations in y, regardless
    of whether they match or not with x.

    ```{r}
    # keep obs in y
    merge(x1, y1, keep = "right")
    ```

-   `keep = "inner"` keeps only the observations that match in both tables.

    ```{r}
    # keep matching obs in both tables
    merge(x1, y1, keep = "inner")
    ```
